# 学習記録

## 目次
- [2025/12/7](#2025127)
  - [LINEユーザーIDについて](#lineユーザーidについて)
  - [スクレイピングについて](#スクレイピングについて)
  - [ngrokとWebhookについて](#ngrokとwebhookについて)
  - [ngrok vs Vercel の選択](#ngrok-vs-vercel-の選択)
  - [個別送信と一斉送信の違い](#個別送信と一斉送信の違い)

---

## 2025/12/7

### LINEユーザーIDについて

- 友達全員のユーザーIDを取得するには、認証済みアカウントまたはプレミアムプランへの加入が必要。
　- 上記以外の場合はWebhookで取得する
　  - 今回のプロジェクトではwebhookを使ったプログラムを実装し、ID取得が必要な場合に手動で実行することによりクライアントのI Dを取得する

#### 参考資料
- [LINE Developersドキュメント](https://developers.line.biz/ja/docs/messaging-api/getting-user-ids/)

---

### スクレイピングについて

- **サイトマップ**: Googleにコンテンツを認識させ、SEO対策やクローラー対策として利用される。
  - 例: `https://slo-map.com/sitemap.xml`
- **robots.txt**: クローラー（ロボット）のアクセスを制御するためのファイル。
  - 例: `https://slo-map.com/robots.txt`
- スクレイピングの善悪は、**悪意の有無**と**サーバーへの負荷**が重要な判断基準となる。
- 画像資料
  ![robots.txt](./images/robots.txt.png)


#### 岡崎市立中央図書館事件（Librahack事件）

この事件以後、Webスクレイピングに関する大きな事件は特に報告されていないが、重要な教訓を残した。

- **事件の経緯**:
  - 2010年3月: ある男性が、岡崎市立中央図書館の新刊情報を自動取得するプログラム（約1秒に1回のアクセス）を実行。
  - 2010年5月25日: 「偽計業務妨害」の容疑で逮捕。理由は「大量アクセスでシステムを利用不能にした」こと。

- **事件の背景**:
  - 図書館側のシステムに脆弱性があり、通常のアクセスでも高負荷に耐えられない状態だった。
  - 男性に攻撃の意図はなく、個人的な情報収集が目的だった。

- **最終的な結果**:
  - **不起訴処分（起訴猶予）** となり、裁判は行われなかった（無罪判決ではない）。

- **影響と教訓**:
  - この事件は、Webスクレイピングの法的リスクと、サービス提供者側のシステム堅牢性の重要性についての議論を巻き起こした。
  - 悪意がなくとも、過度なアクセスでサーバーに負荷をかける行為は業務妨害と見なされるリスクがある。
  - 一般的に、**1秒に1回程度のアクセス**が、サーバーに配慮したアクセス頻度の一つの目安とされている。

---

### ngrokとWebhookについて（分かりやすい版）

#### ngrokの役割：インターネットへの「魔法のトンネル」

`ngrok`を一言でいうと、「**自分のPCで動いている開発中のプログラムを、一時的にインターネットに公開してくれるトンネル役**」です。

- 普通、自分のPC（ローカル環境）は、セキュリティのために外のインターネットから直接アクセスできません。
- でも、LINEみたいな外部サービスからの通知（Webhook）を受け取るには、インターネット上に公開された住所（URL）が必要になります。
- そこで`ngrok`を起動すると、`https://xxxx.ngrok.io` のような誰でもアクセスできる公開URLが作られ、そこに来た通信をすべて手元のPCに転送してくれます。

このプロジェクトでは、LINEからの「メッセージが届いたよ！」という通知を、開発中のPCで受け取るために使っています。

#### Webhookの仕組み：「電話」より「呼び鈴」

`Webhook`は、例えるなら「**呼び鈴（チャイム）**」のような仕組みです。

- 普通のAPI連携が、こちらから「何か新しい情報ありますか？」と何度も聞きに行く（ポーリングする）「**電話をかける**」スタイルだとすると、
- Webhookは、逆にあちら側から「新しい情報が出たよ！」とこちらの指定したURLに通知しに来てくれる「**呼び鈴を鳴らす**」スタイルです。

**このプロジェクトでの流れ：**

1.  ユーザーがLINEボットにメッセージを送る。
2.  LINEのサーバーが「お、メッセージが来たな」と検知する。
3.  LINEのサーバーが、私たちが予め設定しておいたURL（`ngrok`が作ったURL）に、「こんなメッセージが来たよ」という情報を送ってきます。これが**Webhook**です。
4.  `ngrok`のトンネルを通じて、その情報が私たちのPC上のプログラムに届きます。
5.  プログラムが情報を受け取って、在庫チェックなどの処理を始めます。

この「呼び鈴」の仕組みのおかげで、リアルタイムでユーザーの操作に反応できるわけです。

---

### ngrok vs Vercel の選択

今回のプロジェクトでは、ユーザーID取得のためにngrokを使用しました。同じことがVercelでもできますが、用途によって適切な選択が異なります。

#### ngrok（今回採用）

**メリット**:
- ✅ **一時的な用途に最適** - ID取得だけなので一時URLで十分
- ✅ **即起動** - コマンド1つで数秒で起動
- ✅ **デプロイ不要** - ローカルのコードをそのまま公開
- ✅ **後片付けが楽** - Ctrl+Cで終了、痕跡なし

**デメリット**:
- ❌ 常時起動には不向き
- ❌ ngrokを起動している間だけ有効

**適している用途**:
- 一時的なWebhook受信（今回のユーザーID取得）
- 開発中のローカルサーバーをテスト公開
- デモやプレゼンテーション

#### Vercel

**メリット**:
- ✅ **常時稼働** - 24時間365日自動で動く
- ✅ 無料で使える
- ✅ 本番運用向き

**デメリット**:
- ❌ **デプロイが必要** - git push → ビルド → デプロイ
- ❌ **ID取得後も残り続ける** - 使わないのに稼働し続ける
- ❌ 環境変数の設定など手間がかかる

**適している用途**:
- 常時稼働が必要なWebhookサーバー
- 本番環境のAPI
- Webアプリケーションのホスティング

#### 結論

- **たまに使う（一時的）** → ngrok
- **常時稼働させる** → Vercel（またはSupabase Edge Functions、Cloudflare Workersなど）

今回は「たまにユーザーIDを取得する」という一時的な用途だったため、**ngrokが最適**でした。

---

### 個別送信と一斉送信の違い

LINE Messaging APIには、通知の送り方に2つの方式があります。このプロジェクトでは用途に応じてどちらを使うかを検討しました。

#### 1. Push Message（個別送信）

**特徴**:
- 特定のユーザーIDを指定して送信
- ユーザーごとに異なるメッセージを送れる
- ユーザーID管理が必要

**必要なもの**:
- ユーザーIDのデータベース（CSV、Supabase等）
- ユーザーID取得の仕組み（Webhook、手動取得等）

**ディレクトリ構造の例**:
```
gunpla-stock-bot/
├── config/
│   ├── targets.csv          # 監視商品リスト
│   └── users.csv            # ユーザーIDリスト（必要）
├── src/
│   ├── csvHelper.ts         # CSV読み書き（ユーザー管理用）
│   ├── lineMessaging.ts     # Push Message API実装
│   └── main.ts
├── getUserId.js             # ユーザーID手動取得用
└── docs/
    └── GET_USER_ID.md       # ID取得手順書
```

**実装例**:
```typescript
// 個別送信
await client.pushMessage(userId, { type: 'text', text: '在庫復活！' });
```

**用途**:
- ユーザーごとに監視商品を変えたい
- 特定のユーザーだけに通知したい
- ユーザーごとに通知設定を持ちたい

#### 2. Broadcast（一斉送信）

**特徴**:
- Bot友だち全員に自動送信
- ユーザーID不要
- シンプルで管理が楽

**必要なもの**:
- LINE Channel Access Tokenのみ
- ユーザー管理は不要

**ディレクトリ構造の例**:
```
gunpla-stock-bot/
├── config/
│   └── targets.csv          # 監視商品リストのみ
├── src/
│   ├── lineMessaging.ts     # Broadcast API実装
│   └── main.ts
└── docs/
    └── SETUP.md
```

**実装例**:
```typescript
// 一斉送信
await client.broadcast({ type: 'text', text: '在庫復活！' });
```

**用途**:
- 全員に同じ通知を送ればいい
- シンプルな実装がしたい
- ユーザー管理の手間を省きたい

#### このプロジェクトでの選択

**現在のmainブランチ**: Broadcast（一斉送信）を採用予定
- 全友だちに同じ在庫復活通知を送るだけで十分
- ユーザーID管理の手間が不要
- シンプルで保守しやすい

**feature/user-specific-notificationsブランチ**: Push Message（個別送信）の実装を保存
- 将来的にユーザーごとに機能を変えたくなった場合の参考用
- `examples/user-id-management/`にも実装を保存

#### 制限事項

**無料プランの制限**:
- Broadcast: 月5000通まで
- Push Message: 月5000通まで（合計）

**計算例**:
- 30分おき × 30日 = 1440回実行
- 在庫復活が月10回発生 × 友だち50人 = 500通
- → 無料プランで十分
